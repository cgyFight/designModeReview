#include <iostream>

/* 创建型： 工厂，抽象工厂，单例，建造者，原型
 * 结构型： 适配器，装饰器，代理，外观，桥接，组合，享元
 * 行为型(关系型 11种)
 * 	（父子类）适配器，模板方法
 *   (类之间的) 观察者
 *
 */



//行为模式(关系模式)可以概括为
/* 1 . 通过父类与子类实现
 * 	1.1 策略模式
 *  1.2 模板方法模式
 *  1.3
 * 2.  类之间的关系-通过两个类之间实现
 *  2.1 观察者模式 (当一个类又变化时，对它依赖该对象的对象会接到通知（一对多的关系）)
 *
 *
 */



//行为模式  -策略模式
/* 策略模式
 * 概述：定义一些列的算法，将他们封装，让他们可以互相替换，使得算法可以独立于客户而变化
 * 即功能一样接口一样，但实现算法不一样
 *
 * 1. 定义抽象策略角色（为策略对象定义一个公共接口）
 * 2. 编写具体策略角色（子类继承实现接口）
 * 3. 定义环境角色，内部持有一个策略的引用
 *
 * 总结：和工厂模式类似，不同的是这个封装的是方法，工厂模式封装的类
 *
 */
#include "behaviourMode/strategy.h"

// 行为模式 -模板模式
/* 模板模式,将通用的算法方法抽象出来，将关键代码在父类中实现，其它步骤到子类中实现，比如游戏类有玩时有三个步骤，初始化，开始，结束
 * 不同的游戏有不同的初始化，开始，结束步骤
 */
#include "behaviourMode/template.h"


/* 观察者模式
 * 主要解决就是一个目标更新，所有目标更新,比如qt种的信号槽，model/view等
 *
 * 通过一个数据结构保存要更新的目标对象，
 */
#include "behaviourMode/observer.h"


//结构型 适配器模式
// 场景，充电用两个孔的插口，但是这里只有三口的插口，所以通过一个适配器，使得可以使用三孔的插口
#include "StructualType/adapter.h"


// 装饰模式
/*
 * 也就是动态的给一些对象添加一些额外的功能
 * 比如 基类饺子A，有一个子类肉馅饺子B， 现在需要有一个加盐C，加油的饺子D，则使用装饰类继承基类饺子E，并将B传入，使用C，D继承E，在A的方法中添加自己的特性
 */
#include "decorate.h"

//结构型号 外观模式
/*
 * 外观模式
 * 也就是将一系列过程封装起来，对外只暴露一个简单接口
 */
#include "StructualType/faced.h"

// 代理模式
#include "StructualType/proxy.h"



using namespace std;

int main()
{

    if (0) {
        // 测试策略模式
        Rou<APHurt> r;
        r.beHurt();
        cout << "Hello World2!" << endl;
    }

    if (0) {
        // 测试适配器模式
        TestAdpter t;
    }

    if (0) {
        // 测试观察者模式
//        IntDataModel d;
        TestObserver t;
        t.testObserver();
    }

    if (1) {
        TestDecoder td;
        td.testDecoder();
    }

    return 0;
}
