#include <iostream>

//行为模式  -策略模式
/* 策略模式
 * 概述：定义一些列的算法，将他们封装，让他们可以互相替换，使得算法可以独立于客户而变化
 * 即功能一样接口一样，但实现算法不一样
 *
 * 1. 定义抽象策略角色（为策略对象定义一个公共接口）
 * 2. 编写具体策略角色（子类继承实现接口）
 * 3. 定义环境角色，内部持有一个策略的引用
 *
 * 总结：和工厂模式类似，不同的是这个封装的是方法，工厂模式封装的类
 *
 */
#include "behaviourMode/strategy.h"

// 行为模式 -模板模式
/* 模板模式,将通用的算法方法抽象出来，将关键代码在父类中实现，其它步骤到子类中实现，比如游戏类有玩时有三个步骤，初始化，开始，结束
 * 不同的游戏有不同的初始化，开始，结束步骤
 */
#include "behaviourMode/template.h"


//结构型 适配器模式
// 场景，充电用两个孔的插口，但是这里只有三口的插口，所以通过一个适配器，使得可以使用三孔的插口
#include "StructualType/adapter.h"

//结构型号 外观模式
/*
 * 外观模式
 * 也就是将一系列过程封装起来，对外只暴露一个简单接口
 */
#include "StructualType/faced.h"


// 装饰模式
/*
 * 也就是动态的给一些对象添加一些额外的功能
 * 比如 基类饺子A，有一个子类肉馅饺子B， 现在需要有一个加盐C，加油的饺子D，则使用装饰类继承基类饺子E，并将B传入，使用C，D继承E，在A的方法中添加自己的特性
 */

using namespace std;

int main()
{

    if (0) {
        // 测试策略模式
        Rou<APHurt> r;
        r.beHurt();
        cout << "Hello World2!" << endl;
    }

    if (1) {
        // 测试适配器模式
        TestAdpter t;
    }

    return 0;
}
